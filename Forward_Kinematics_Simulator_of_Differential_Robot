import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, Button, CheckButtons
from matplotlib.patches import Polygon

# ---------------------------
# Differential Drive Simulator
# ---------------------------

# ----- Parameters -----
r = 0.05     # wheel radius [m]
L = 0.40     # wheel track [m]
Ts = 0.05    # integration timestep [s]

# Visual geometry
body_len = 0.60
body_wid = 0.36
wheel_len = 0.14
wheel_wid = 0.05

# Initial state
X = 0.0
Y = 0.0
alpha = 0.0

# Initial wheel speeds (rad/s)
wl = 6.0
wr = 6.0

# state derived from wheel speeds
def wheels_to_Vw(wl_val, wr_val):
    Vl = r * wl_val
    Vr = r * wr_val
    V = (Vr + Vl) / 2.0
    w = (Vr - Vl) / L
    return V, w, Vl, Vr

def Vw_to_wheels(V_val, w_val):
    Vr = V_val + 0.5 * L * w_val
    Vl = V_val - 0.5 * L * w_val
    wr_val = Vr / r
    wl_val = Vl / r
    return wl_val, wr_val, Vl, Vr

def icr_from_Vw(V_val, w_val, Xc, Yc, alpha_c):
    # returns (R, x_icr, y_icr). If straight-line motion, R = +inf
    if abs(w_val) < 1e-9:
        return np.inf, np.nan, np.nan
    R = V_val / w_val
    x_icr = Xc - R * np.sin(alpha_c)
    y_icr = Yc + R * np.cos(alpha_c)
    return R, x_icr, y_icr

def rot2d(theta):
    c, s = np.cos(theta), np.sin(theta)
    return np.array([[c, -s], [s, c]])

def rect_polygon(cx, cy, length, width, heading):
    half_l, half_w = length / 2.0, width / 2.0
    corners_local = np.array([
        [ half_l,  half_w],
        [ half_l, -half_w],
        [-half_l, -half_w],
        [-half_l,  half_w],
    ])
    Rm = rot2d(heading)
    pts = (Rm @ corners_local.T).T + np.array([cx, cy])
    return pts

# Initialize derived V and w
V, w, Vl, Vr = wheels_to_Vw(wl, wr)

# Prevent recursive slider updates
_updating = {"flag": False}
timer = None

# ----- Matplotlib figure & artists -----
plt.close("all")
fig = plt.figure(figsize=(10, 7))
ax = fig.add_axes([0.06, 0.08, 0.66, 0.88])
ax.set_aspect("equal", adjustable="box")
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
ax.grid(True, alpha=0.3)
ax.set_title("Differential Drive Forward Kinematics")

# Path trace
path_x, path_y = [X], [Y]
path_line, = ax.plot(path_x, path_y, lw=1.5, alpha=0.8)

# Robot body polygon
body_poly = Polygon(rect_polygon(X, Y, body_len, body_wid, alpha), closed=True,
                    facecolor=(0.2, 0.5, 1.0, 0.25), edgecolor="k", lw=1.5)
ax.add_patch(body_poly)

# Four wheels (visual)
wheel_offsets_body = [
    ( body_len*0.30,  body_wid/2 + wheel_wid/2),  # front-right (body frame)
    ( body_len*0.30, -body_wid/2 - wheel_wid/2),  # front-left
    (-body_len*0.30,  body_wid/2 + wheel_wid/2),  # rear-right
    (-body_len*0.30, -body_wid/2 - wheel_wid/2),  # rear-left
]
wheel_polys = []
for _ in wheel_offsets_body:
    poly = Polygon(rect_polygon(X, Y, wheel_len, wheel_wid, alpha), closed=True,
                   facecolor=(0.12, 0.12, 0.12, 0.9), edgecolor="k", lw=1.0)
    ax.add_patch(poly)
    wheel_polys.append(poly)

# Heading arrow
head_len = body_len * 0.55
arrow_line, = ax.plot([], [], lw=2.0)

# ICR marker
icr_marker = ax.scatter([], [], s=30, marker="x")

# Info box
infotxt = ax.text(0.99, 0.98, "", transform=ax.transAxes, ha="right", va="top",
                  bbox=dict(boxstyle="round", facecolor="white", alpha=0.90, lw=0.8),
                  family="monospace", fontsize=9)

def update_robot_artist():
    """Update polygons, arrow, path, ICR marker and info text."""
    # update body
    body_poly.set_xy(rect_polygon(X, Y, body_len, body_wid, alpha))
    # update wheels
    Rm = rot2d(alpha)
    for poly, (ox, oy) in zip(wheel_polys, wheel_offsets_body):
        wx, wy = (Rm @ np.array([ox, oy])) + np.array([X, Y])
        poly.set_xy(rect_polygon(wx, wy, wheel_len, wheel_wid, alpha))
    # heading arrow
    nose = np.array([X, Y]) + head_len * np.array([np.cos(alpha), np.sin(alpha)])
    arrow_line.set_data([X, nose[0]], [Y, nose[1]])
    # ICR
    Rcur, x_icr, y_icr = icr_from_Vw(V, w, X, Y, alpha)
    if np.isfinite(Rcur):
        icr_marker.set_offsets([[x_icr, y_icr]])
    else:
        # set a 2D empty array so matplotlib doesn't raise IndexError
        icr_marker.set_offsets(np.empty((0, 2)))
    # path
    path_line.set_data(path_x, path_y)
    # info box
    R_str = f"{Rcur: .3f} m" if np.isfinite(Rcur) else "  âˆž"
    info = (
        f"ICR R: {R_str}\n"
        f"w: {w: .4f} rad/s\n"
        f"alpha: {alpha: .4f} rad\n"
        f"X: {X: .3f} m\n"
        f"Y: {Y: .3f} m"
    )
    infotxt.set_text(info)

# ----- UI controls  -----
axcolor = "lightgoldenrodyellow"
ax_wl = fig.add_axes([0.78, 0.78, 0.18, 0.03], facecolor=axcolor)
ax_wr = fig.add_axes([0.78, 0.73, 0.18, 0.03], facecolor=axcolor)
ax_V  = fig.add_axes([0.78, 0.62, 0.18, 0.03], facecolor=axcolor)
ax_w  = fig.add_axes([0.78, 0.57, 0.18, 0.03], facecolor=axcolor)
ax_ts = fig.add_axes([0.78, 0.46, 0.18, 0.03], facecolor=axcolor)

# note: wheel slider range
s_wl = Slider(ax_wl, "wl [rad/s]", -100.0, 100.0, valinit=wl, valstep=0.01)
s_wr = Slider(ax_wr, "wr [rad/s]", -100.0, 100.0, valinit=wr, valstep=0.01)
s_V  = Slider(ax_V,  "V [m/s]",   -2.0, 2.0, valinit=V, valstep=0.001)
s_w  = Slider(ax_w,  "w [rad/s]", -10.0, 10.0, valinit=w, valstep=0.001)
s_ts = Slider(ax_ts, "Ts [s]",     0.01, 0.2, valinit=Ts, valstep=0.005)

ax_btn_run = fig.add_axes([0.78, 0.36, 0.085, 0.05])
ax_btn_rst = fig.add_axes([0.875, 0.36, 0.085, 0.05])
btn_run = Button(ax_btn_run, "Run/Pause")
btn_rst = Button(ax_btn_rst, "Reset")

ax_chk = fig.add_axes([0.78, 0.26, 0.18, 0.09])
chk = CheckButtons(ax_chk, ["Show ICR", "Leave Path"], [True, True])
chk_labels = [lbl.get_text() for lbl in chk.labels]  # capture strings

_running = {"flag": True}

# ----- Callbacks -----
def _sync_from_wheels():
    """When wl/wr change, update V and w (and update V/w sliders)."""
    global V, w, wl, wr
    Vn, wn, _, _ = wheels_to_Vw(s_wl.val, s_wr.val)
    wl, wr = s_wl.val, s_wr.val
    if not _updating["flag"]:
        _updating["flag"] = True
        # update derived sliders
        s_V.set_val(Vn)
        s_w.set_val(wn)
        _updating["flag"] = False
    V, w = Vn, wn

def _sync_from_Vw():
    """When V/w change, compute wl/wr and update their sliders."""
    global V, w, wl, wr
    wl_n, wr_n, _, _ = Vw_to_wheels(s_V.val, s_w.val)
    V, w = s_V.val, s_w.val
    if not _updating["flag"]:
        _updating["flag"] = True
        s_wl.set_val(wl_n)
        s_wr.set_val(wr_n)
        _updating["flag"] = False
    wl, wr = s_wl.val, s_wr.val

def on_wl(val):
    if _updating["flag"]:
        return
    _sync_from_wheels()

def on_wr(val):
    if _updating["flag"]:
        return
    _sync_from_wheels()

def on_V(val):
    if _updating["flag"]:
        return
    _sync_from_Vw()

def on_w(val):
    if _updating["flag"]:
        return
    _sync_from_Vw()

def on_ts(val):
    global Ts, timer
    Ts = s_ts.val
    if timer is not None and hasattr(timer, "interval"):
        timer.interval = int(Ts * 1000)

s_wl.on_changed(on_wl)
s_wr.on_changed(on_wr)
s_V.on_changed(on_V)
s_w.on_changed(on_w)
s_ts.on_changed(on_ts)

def toggle_run(event):
    _running["flag"] = not _running["flag"]

def do_reset(event):
    global X, Y, alpha, path_x, path_y
    X, Y, alpha = 0.0, 0.0, 0.0
    path_x, path_y = [X], [Y]
    update_robot_artist()
    fig.canvas.draw_idle()

btn_run.on_clicked(toggle_run)
btn_rst.on_clicked(do_reset)

def on_check(label):
    # use captured strings
    states = dict(zip(chk_labels, chk.get_status()))
    show_icr = states.get("Show ICR", True)
    leave_path = states.get("Leave Path", True)
    icr_marker.set_visible(show_icr)
    if not leave_path:
        path_x.clear()
        path_y.clear()
        path_x.append(X)
        path_y.append(Y)
    fig.canvas.draw_idle()

chk.on_clicked(on_check)

# ----- Simulation step -----
def step():
    global X, Y, alpha, V, w
    if not _running["flag"]:
        return
    X += V * Ts * np.cos(alpha)
    Y += V * Ts * np.sin(alpha)
    alpha += w * Ts
    # wrap angle neatly
    alpha = (alpha + np.pi) % (2 * np.pi) - np.pi
    path_x.append(X)
    path_y.append(Y)
    update_robot_artist()
    fig.canvas.draw_idle()

# Create and start backend-agnostic timer
timer = fig.canvas.new_timer(interval=int(Ts * 1000))
timer.add_callback(step)
timer.start()

# Initial draw
update_robot_artist()
plt.show()
